---
layout: post
title: JVM ClassLoader API docs
---

类加载器负责加载类。ClassLoader是一个抽象类。给定类的二进制名称，类加载器应该尝试定位，生成构成类定义的数据。
一个典型的策略是，将类的二进制名称转换成文件名，然后从文件系统中读取。

每一个Class对象都包含一个定义他自身的ClassLoader引用。

数组类型的Class对象不是由类加载器创建的，它由Java在运行时自动创建的。
数组类型的类加载器由Class.getClassLoader() 方法返回，它和数组中元素的类加载器是一样的。
如果元素是原生类型的，数组类型没有类加载器(null)。

实现了ClassLoader的子类的应用程序为了扩展Java虚拟机动态加载类的方式。

类加载器通常被安全管理器用来表示安全域。

ClassLoader 类使用委托模式寻找类和资源。ClassLoader的每一个实例都有一个与之关联的父类加载器。
当需要寻找类和资源的时候，ClassLoader 的实例在自己查找之前，将委托它的父类加载器。虚拟机有一个内置的类加载器，
"bootstrap class loader",（启动类加载器），没有双亲，但是可以作为ClassLoader实例的父类加载器。 

支持并发地加载类的类加载器被称为并行类加载器，并且需要在class初始化期间注册，
通过调用 ClassLoader.registerAsParallelCapable()方法。注意，ClassLoader 类默认被注册为并行的。
然而，如果他的子类是并行的话，还是需要自己注册。
    在委托模型不是非常严格的环境下，类加载器需要是并行的，否则，类加载器会导致死锁，
因为在类加载过程期间，类加载器一直持有锁。

通常情况下，Java虚拟机会在本地文件系统中加载类，以平台相关的方式。例如：在 UNIX 系统中，虚拟机是在
CLASSPATH环境变量定义的目录中加载类。

然而，有些类并不是来源于文件，它们可能来自其他来源，像网络，或者由应用程序创建。
defineClass()方法 将字节数组转换为类的Class实例。使用Class.newInstance.()来创建当前新定义的类实例。