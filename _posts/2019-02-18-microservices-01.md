---
layout: post
title: Microservices
---

翻译自Martin Fowler的[microservices](https://www.martinfowler.com/articles/microservices.html), 翻译于2019年2月18日。

### （microservices）新架构术语的定义
“微服务架构”在过去几年中出现，它描述了一种特定方式：`将软件应用程序设计为一组可独立部署的服务`。尽管这种架构风格没有严格的定义，但是在组织、业务能力上有一些共同的特征：自动化部署、端点智能化，语言和数据的去中心化控制。

“微服务”——软件架构拥挤大街上的又一个新术语。尽管我们倾向于将其一带而过，但是我们发现它描述了一种越来越吸引人的软件系统风格。在过去的几年里我们看到很多项目使用这种风格，并且到目前为止结果都还不错，以致于这已经变成了我们同事在构建企业级应用时默认使用的架构风格。然而，遗憾的是，并没有太多信息来概括什么是微服务风格以及如何实现它。

简而言之，微服务架构风格[[1]](#fn1)是一种将单个应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，服务间的通信采用轻量级机制(通常是HTTP资源API)。这些服务围绕业务功能构建，并可通过全自动部署机制独立部署。这些服务共用一个最小型的集中式的管理，服务可用不同的语言开发，使用不同的数据存储技术。

与单体风格作对比有助于开始解释微服务风格：单体应用程序被构建为单一单元。企业应用程序通常由三部分组成：客户端用户接口（由用户机器上浏览器中运行的HTML页面和javascript组成），数据库（由插入到通用关系型数据库管理系统的许多表组成），服务端应用程序。服务器端应用程序将处理 HTTP 请求、执行域逻辑、从数据库检索和更新数据，并选择和填充要发送到浏览器的 HTML 视图。服务端应用程序是一个单一的逻辑可执行单体[[2]](#fn2)。对系统的任何更改都涉及构建和部署服务器端应用程序的新版本。

这样的单体服务器是构建这样的系统最自然的方式。处理请求的所有逻辑都运行在单个进程中，允许使用语言的基本特性将应用程序划分为类、函数和命名空间。您认真地在开发人员的笔记本上运行和测试应用程序，并使用部署管道确保那些变更被完全地测试部署到生产环境中。该单体的水平扩展可以通过在负载均衡器后面运行多个实例来实现。

单体应用程序可以是成功的，但人们日益对他们感到挫败，尤其是随着更多的应用程序被部署在云上。变更周期被捆绑在一起 —— 即使只变更应用程序的一部分，也需要重新构建并部署整个单体。长此以往，通常将很难保持一个良好的模块架构，很难只在需要变更的模块内进行变更。程序扩展要求进行整个应用程序的扩展，而不是需要更多资源的应用程序部分的扩展。

![microservices](https://raw.githubusercontent.com/xiejianwei1024/markdownphotos/master/microservices/sketch.png)
图1：单体和微服务

这些不满导致了微服务架构风格的诞生：以构建一组小型服务的方式来构建应用程序。除了服务是可独立部署和可伸缩的这一事实之外，每个服务还提供了一个严格的模块边界，甚至允许用不同的编程语言编写不同的服务。这些服务也能被不同的团队管理。

我们并不认为微服务风格是新颖的或创新的，其本质至少可以追溯到Unix的设计哲学。但是我们认为，考虑微服务架构的人还不够多，并且如果对其加以使用，许多软件的开发工作能变得更好。

### 微服务架构的特征（九个）
我们无法给出微服务架构风格的一个正式定义，但我们可以尝试去描述我们看到的符合该架构的一些共性。下面所描述的所有这些共性，并不是所有的微服务架构都完全具备，但是我们确实期望大多数微服务架构都具备这些共性中的大多数特性。尽管本文（我们两位）作者已经是这个相当松散的社区的活跃成员，我们的本意还是试图描述我们在工作中和在我们所了解的一些团队，在他们的工作中的所见所闻。特别指出，我们不会制定大家需要遵循的微服务的定义。

#### 1.通过服务组件化
自从我们涉足软件行业以来，就一直希望通过将组件组装在一起来构建系统，就像我们看到的现实世界中事物的构建方式一样。在过去几十年中，我们已经看到，在公共软件库方面已经取得了相当大的进展，这些软件库是大多数编程语言平台的组成部分。

当谈到组件时，就会碰到一个有关定义的难题，即什么是组件？我们的定义是：<span style="bold">组件</span>是一个可以独立更换和升级的软件单元。

微服务架构也会使用软件库，但其将自身软件进行组件化的主要方法是将软件分解为诸多服务。我们将<span style="bold">软件库(libraries)</span>定义为这样的组件，即它能被链接到一段程序，且能通过内存中的函数来进行调用。然而，服务(services)是进程外的组件，它们通过诸如web service请求或rpc（远程过程调用）这样的机制来进行通信（这不同于许多面向对象的程序中的service object概念[[3]](#fn3)）。

使用服务（而不是以软件库）的方式来实现组件化的一个主要原因是，服务可被独立部署。如果有一个应用程序[[4]](#fn4)）是由在单一进程里的多个软件库所组成的，任何一个组件的的更改都导致必须重新部署整个应用程序。但如果应用程序分解成多个服务，那么单个服务的变更只需要重新部署该服务即可。当然这也不是绝对的，一些服务接口的修改会导致多个服务之间的协同修改。但是一个良好的微服务架构的目的，是通过内聚的服务边界和服务协议方面的演进机制，来将这样的修改变得最小化。

使用服务作为组件的另一个结果是获得更加显示的组件接口。大多数编程语言并没有一个良好的机制来定义显式的[发布接口](https://www.martinfowler.com/bliki/PublishedInterface.html)。通常情况下，这样的接口仅仅是文档声明和团队纪律，来避免客户端破坏组件的封装，从而导致组件间出现过度紧密的耦合。服务通过显示的远程调用机制可以很容易的避免这种情况发生。

如此使用服务，也会有不足之处。比起进程内调用，远程调用更加昂贵。所以远程调用API接口必须是粗粒度的，而这往往更加难以使用。如果需要修改组件间的职责分配，那么当跨越进程边界时，这种组件行为的改动会更加难以实现。

近似地，我们可以把一个个服务映射为一个个运行时的进程，但这仅仅是一个近似。一个服务可能由多进程组成，这些进程总是被一起开发和部署，比如一个应用程序的进程和仅被该服务使用的数据库。

#### 2.围绕业务功能组织团队
当在寻求将一个大型应用系统分解成几部分时，公司管理层往往会聚焦在技术层面上，这就意味着要组建用户界面团队、服务器端团队和数据库团队。当团队沿着这些技术线分开后，即使要实现软件中一个简单的变更，也会发生跨团队的项目时延和预算审批。在这种情况下，聪明的团队会进行局部优化，“两害相权取其轻”，来直接把代码逻辑塞到他们能访问到的任意应用系统中。换句话说，这种情况会导致代码逻辑散布在系统各处。这就是康威定律[[5]](#fn5)的鲜活实例。

`任何设计（广义上的）系统的组织，都会产生这样一个设计，即该设计的结构与该组织的沟通结构相一致。——梅尔文•康威（Melvyn Conway）, 1967年`

![microservices](https://raw.githubusercontent.com/xiejianwei1024/markdownphotos/master/microservices/conways-law.png)
图2：康威定律在起作用

微服务使用不同的方法来分解系统，即根据业务功能（business capability）来将系统分解为若干服务。这些服务针对该业务领域提供多层次、广泛的软件实现，包括用户界面、持久性存储以及任何对外的协作性操作。因此，团队是跨职能的，它拥有软件开发所需的全方位的技能：用户体验、数据库和项目管理。

![microservices](https://raw.githubusercontent.com/xiejianwei1024/markdownphotos/master/microservices/PreferFunctionalStaffOrganization.png)
图3：被团队边界所强化的服务边界

以上述方式来组织团队的公司是[www.comparethemarket.com](http://www.comparethemarket.com)。跨职能团队负责构建和运维每个产品，而每个产品被拆分为多个独立的服务，彼此通过一个消息总线来通信。

------------------
侧边栏：微服务有多大？
尽管“微服务”已经成为这种架构风格的一个流行名称，但是这个名字确实会不幸地引发大家对服务规模的关注，并且产生有关什么是“微”的争论。在我们与微服务从业人员的对话中，我们看到了各种规模的服务。据报道，最大的披萨店遵循了亚马逊的“两个披萨团队”(即整个团队可以吃两个披萨)的理念，即最多只能容纳12个人。在较小的规模上，我们已经看到了由6个人组成的团队支持6个服务。

这引出了一个问题，即“每12人做一个服务”和“每人做一个服务”这样有关服务规模的差距，是否已经大到不能将两者都纳入微服务之下？此时，我们认为最好还是把它们归为一类，但是随着探索的深入，我们将来极有可能会改变主意。
------------------

大型单体应用程序也可以围绕业务功能进行模块化，尽管这种情况并不常见。当然，我们会敦促构建单体应用程序的大型团队按照业务线来将自己分解为若干小团队。我们在这里看到的主要问题是，它们往往是一个团队包含了太多的业务功能。如果这个“单体”跨越了许多模块的边界，那么这个团队的每一个成员都难以记住所有模块的业务功能。此外，我们看到这些模块的边界需要大量的团队纪律来强制维持。而实现组件化的服务所必要的更加显式的边界，能更加容易地保持团队边界的清晰性。


### 脚注
<span id="fn1">1</span>术语“微服务”

<span id="fn2">2</span>

<span id="fn3">3</span>

<span id="fn4">4</span>

<span id="fn5">5</span>