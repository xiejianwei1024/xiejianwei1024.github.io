---
layout: post
title: Microservices
---

翻译自Martin Fowler的[microservices](https://www.martinfowler.com/articles/microservices.html), 翻译于2019年2月18日。

### （microservices）新架构术语的定义
“微服务架构”在过去几年中出现，它描述了一种特定方式：`将软件应用程序设计为一组可独立部署的服务`。尽管这种架构风格没有严格的定义，但是在组织、业务能力上有一些共同的特征：自动化部署、端点智能化，语言和数据的去中心化控制。

“微服务”——软件架构拥挤大街上的又一个新术语。尽管我们倾向于将其一带而过，但是我们发现它描述了一种越来越吸引人的软件系统风格。在过去的几年里我们看到很多项目使用这种风格，并且到目前为止结果都还不错，以致于这已经变成了我们同事在构建企业级应用时默认使用的架构风格。然而，遗憾的是，并没有太多信息来概括什么是微服务风格以及如何实现它。

简而言之，微服务架构风格[[1]](#fn1)是一种将单个应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，服务间的通信采用轻量级机制(通常是HTTP资源API)。这些服务围绕业务功能构建，并可通过全自动部署机制独立部署。这些服务共用一个最小型的集中式的管理，服务可用不同的语言开发，使用不同的数据存储技术。

与单体风格作对比有助于开始解释微服务风格：单体应用程序被构建为单一单元。企业应用程序通常由三部分组成：客户端用户接口（由用户机器上浏览器中运行的HTML页面和javascript组成），数据库（由插入到通用关系型数据库管理系统的许多表组成），服务端应用程序。服务器端应用程序将处理 HTTP 请求、执行域逻辑、从数据库检索和更新数据，并选择和填充要发送到浏览器的 HTML 视图。服务端应用程序是一个单一的逻辑可执行单体[[2]](#fn2)。对系统的任何更改都涉及构建和部署服务器端应用程序的新版本。

这样的单体服务器是构建这样的系统最自然的方式。处理请求的所有逻辑都运行在单个进程中，允许使用语言的基本特性将应用程序划分为类、函数和命名空间。您认真地在开发人员的笔记本上运行和测试应用程序，并使用部署管道确保那些变更被完全地测试部署到生产环境中。该单体的水平扩展可以通过在负载均衡器后面运行多个实例来实现。

单体应用程序可以是成功的，但人们日益对他们感到挫败，尤其是随着更多的应用程序被部署在云上。变更周期被捆绑在一起 —— 即使只变更应用程序的一部分，也需要重新构建并部署整个单体。长此以往，通常将很难保持一个良好的模块架构，很难只在需要变更的模块内进行变更。程序扩展要求进行整个应用程序的扩展，而不是需要更多资源的应用程序部分的扩展。

![microservices](https://raw.githubusercontent.com/xiejianwei1024/markdownphotos/master/microservices/sketch.png)
图1：单体和微服务

这些不满导致了微服务架构风格的诞生：以构建一组小型服务的方式来构建应用程序。除了服务是可独立部署和可伸缩的这一事实之外，每个服务还提供了一个严格的模块边界，甚至允许用不同的编程语言编写不同的服务。这些服务也能被不同的团队管理。

我们并不认为微服务风格是新颖的或创新的，其本质至少可以追溯到Unix的设计哲学。但是我们认为，考虑微服务架构的人还不够多，并且如果对其加以使用，许多软件的开发工作能变得更好。

### 微服务架构的特征（九个）
我们无法给出微服务架构风格的一个正式定义，但我们可以尝试去描述我们看到的符合该架构的一些共性。下面所描述的所有这些共性，并不是所有的微服务架构都完全具备，但是我们确实期望大多数微服务架构都具备这些共性中的大多数特性。尽管本文（我们两位）作者已经是这个相当松散的社区的活跃成员，我们的本意还是试图描述我们在工作中和在我们所了解的一些团队，在他们的工作中的所见所闻。特别指出，我们不会制定大家需要遵循的微服务的定义。

#### 1.通过服务组件化
自从我们涉足软件行业以来，就一直希望通过将组件组装在一起来构建系统，就像我们看到的现实世界中事物的构建方式一样。在过去几十年中，我们已经看到，在公共软件库方面已经取得了相当大的进展，这些软件库是大多数编程语言平台的组成部分。

当谈到组件时，就会碰到一个有关定义的难题，即什么是组件？我们的定义是：<span style="bold">组件</span>是一个可以独立更换和升级的软件单元。

微服务架构也会使用软件库，但其将自身软件进行组件化的主要方法是将软件分解为诸多服务。我们将<span style="bold">软件库(libraries)</span>定义为这样的组件，即它能被链接到一段程序，且能通过内存中的函数来进行调用。然而，服务(services)是进程外的组件，它们通过诸如web service请求或rpc（远程过程调用）这样的机制来进行通信（这不同于许多面向对象的程序中的service object概念[[3]](#fn3)）。

使用服务（而不是以软件库）的方式来实现组件化的一个主要原因是，服务可被独立部署。如果有一个应用程序[[4]](#fn4)）是由在单一进程里的多个软件库所组成的，任何一个组件的的更改都导致必须重新部署整个应用程序。但如果应用程序分解成多个服务，那么单个服务的变更只需要重新部署该服务即可。当然这也不是绝对的，一些服务接口的修改会导致多个服务之间的协同修改。但是一个良好的微服务架构的目的，是通过内聚的服务边界和服务协议方面的演进机制，来将这样的修改变得最小化。

使用服务作为组件的另一个结果是获得更加显示的组件接口。大多数编程语言并没有一个良好的机制来定义显式的[发布接口](https://www.martinfowler.com/bliki/PublishedInterface.html)。通常情况下，这样的接口仅仅是文档声明和团队纪律，来避免客户端破坏组件的封装，从而导致组件间出现过度紧密的耦合。服务通过显示的远程调用机制可以很容易的避免这种情况发生。

如此使用服务，也会有不足之处。比起进程内调用，远程调用更加昂贵。所以远程调用API接口必须是粗粒度的，而这往往更加难以使用。如果需要修改组件间的职责分配，那么当跨越进程边界时，这种组件行为的改动会更加难以实现。

近似地，我们可以把一个个服务映射为一个个运行时的进程，但这仅仅是一个近似。一个服务可能由多进程组成，这些进程总是被一起开发和部署，比如只被这个服务使用的应用进程和数据库。

#### 2.围绕业务功能组织团队
当在寻求将一个大型应用系统分解成几部分时，公司管理层往往会聚焦在技术层面上，这就意味着要组建用户界面团队、服务器端团队和数据库团队。当团队沿着这些技术线分开后，即使要实现软件中一个简单的变更，也会发生跨团队的项目时延和预算审批。在这种情况下，聪明的团队会进行局部优化，“两害相权取其轻”，来直接把代码逻辑塞到他们能访问到的任意应用系统中。换句话说，这种情况会导致代码逻辑散布在系统各处。这就是康威定律[[5]](#fn5)的鲜活实例。

`任何设计（广义上的）系统的组织，都会产生这样一个设计，即该设计的结构与该组织的沟通结构相一致。——梅尔文•康威（Melvyn Conway）, 1967年`

![microservices](https://raw.githubusercontent.com/xiejianwei1024/markdownphotos/master/microservices/conways-law.png)
图2：康威定律在起作用

微服务使用不同的方法来分解系统，即根据业务功能（business capability）来将系统分解为若干服务。这些服务针对该业务领域提供多层次、广泛的软件实现，包括用户界面、持久性存储以及任何对外的协作性操作。因此，团队是跨职能的，它拥有软件开发所需的全方位的技能：用户体验、数据库和项目管理。

![microservices](https://raw.githubusercontent.com/xiejianwei1024/markdownphotos/master/microservices/PreferFunctionalStaffOrganization.png)
图3：被团队边界所强化的服务边界

以上述方式来组织团队的公司是[www.comparethemarket.com](http://www.comparethemarket.com)。跨职能团队负责构建和运维每个产品，而每个产品被拆分为多个独立的服务，彼此通过一个消息总线来通信。

------------------
侧边栏：微服务有多大？
尽管“微服务”已经成为这种架构风格的一个流行名称，但是这个名字确实会不幸地引发大家对服务规模的关注，并且产生有关什么是“微”的争论。在我们与微服务从业人员的对话中，我们看到了各种规模的服务。据报道，最大的披萨店遵循了亚马逊的“两个披萨团队”(即整个团队可以吃两个披萨)的理念，即最多只能容纳12个人。在较小的规模上，我们已经看到了由6个人组成的团队支持6个服务。

这引出了一个问题，即“每12人做一个服务”和“每人做一个服务”这样有关服务规模的差距，是否已经大到不能将两者都纳入微服务之下？此时，我们认为最好还是把它们归为一类，但是随着探索的深入，我们将来极有可能会改变主意。

------------------

大型单体应用程序也可以围绕业务功能进行模块化，尽管这种情况并不常见。当然，我们会敦促构建单体应用程序的大型团队按照业务线来将自己分解为若干小团队。我们在这里看到的主要问题是，它们往往是一个团队包含了太多的业务功能。如果这个“单体”跨越了许多模块的边界，那么这个团队的每一个成员都难以记住所有模块的业务功能。此外，我们看到这些模块的边界需要大量的团队纪律来强制维持。而实现组件化的服务所必要的更加显式的边界，能更加容易地保持团队边界的清晰性。

#### 3.“做产品”而不是“做项目”
我们所看到的大多数应用程序的开发工作都使用这样一种项目模型：目标是交付某一块软件，之后就认为完工了。一旦完工后，软件就被移交给维护团队，接着那个构建该软件的项目团队就会被解散。

微服务的支持者们倾向于避免上述模型，而宁愿采纳“一个团队在一个产品的整个生命周期中都应该保持对其拥有”的理念。通常认为这一点源自于亚马逊的“谁构建，谁运行”的理念，即一个开发团队对一个在生产环境下的软件负全责。这使得开发人员每天都会关注他们的软件在生产环境下是如何运行的，并且增进了他们与客户间的联系，因为他们必须承担一些支持工作。

这样的“产品”理念，是与业务功能联动绑定在一起的。与其将软件视为一组要完成的功能，还不如将其视为一种持续的关系，即软件如何帮助用户持续增强业务功能。

单体应用程序的开发工作也可以遵循上述“产品”理念，但是更小粒度的服务会让服务的开发者和其用户之间的个人关系变得更加容易。

#### 4.“智能端点”与“傻瓜管道”
当在不同的进程之间构建各种通信结构时，我们已经看到许多产品和方法，来强调将大量的智能特性纳入通信机制本身。其中一个典型例子，就是“企业服务总线”(Enterprise Service Bus, ESB)。ESB产品经常包括高度智能的设施，来进行消息的路由、编制(choreography)、转换，并应用业务规则。

------------------
侧边栏：微服务和SOA
当我们谈起微服务时，一个常见的问题就会出现：微服务是否仅仅是十多年前所看到的“面向服务的架构”(Service Oriented Architecture, SOA)？这样问是有道理的，因为微服务风格非常类似于一些支持SOA的人所赞成的观点。然而，问题在于[SOA这个词儿意味着太多不同的东西](https://martinfowler.com/bliki/ServiceOrientedAmbiguity.html)。而且大多数时候，我们所遇到的某些被称作”SOA”的事物，明显不同于本文所描述的风格。这通常由于它们专注于ESB，来集成各个单体应用。

特别地，我们已经看到如此之多的面向服务的拙劣实现——从将系统复杂性隐藏于ESB中的趋势[[6]](#fn6)，到花费数百万进行多年却没有交付任何价值的失败项目，到顽固抑制变化发生的中心化技术治理模型——以至于有时觉得其所造成的种种问题真的不堪回首。

当然，在微服务社区投入使用的许多技术，源自各个开发人员将各种服务集成到各个大型组织的经验。“容错读取”(Tolerant Reader)模式就是这样一个例子。对于Web的广泛使用，使得人们不再使用一些中心化的标准，而使用一些简单的协议。坦率地说，这些中心化的标准，其复杂性已经达到令人吃惊的程度。（任何时候，如果需要一个本体来管理其他各个本体，那么麻烦就大了。）

这种常见的SOA表现，已使得一些微服务的倡导者完全拒绝将自己贴上SOA的标签。尽管其他人会将微服务看作是SOA的一种形式[8]，也许微服务就是以正确的形式来实现面向服务的SOA。不管是哪种情况，SOA意味着如此之多的不同事物，这表明用一个更加干净利落的术语来命名这种架构风格是很有价值的。

------------------

微服务社区主张采用另一种做法：智能端点(smart endpoints)和傻瓜管道(dumb pipes)。使用微服务所构建的各个应用的目标，都是尽可能地实现“高内聚和低耦合”——他们拥有自己的领域逻辑，并且更像是经典Unix的“过滤器”(filter)那样来工作——即接收一个请求，酌情对其应用业务逻辑，并产生一个响应。这些应用通过使用一些简单的REST风格的协议来进行编制，而不去使用诸如下面这些复杂的协议，即”WS-编制”(WS-Choreography)、BPEL或通过位于中心的工具来进行编排(orchestration)。

微服务最常用的两种协议是：带有资源API的HTTP“请求－响应”协议，和轻量级的消息发送协议[[8]](#fn8)。对于前一种协议的最佳表述是：

`成为Web，而不是躲着Web (Be of the web, not behind the web)——Ian Robinson`

这些微服务团队在开发中，使用的是在构建万维网(world wide web)时所使用的原则和协议（并且在很大程度上，这些原则和协议也是在构建Unix系统时所使用的）。那些被使用过的HTTP资源，通常能被开发或运维人员轻易地缓存起来。

最常用的第二种协议，是通过一个轻量级的消息总线来进行消息发送。此时所选择的基础设施通常是“傻瓜”(dumb)型的(仅仅像消息路由器所做的事情那样傻瓜)——像RabbitMQ或ZeroMQ那样的简单实现，即除了提供可靠的异步机制(fabric)以外不做其他任何事情——智能功能存在于那些生产和消费诸多消息的各个端点中，即存在于各个服务中。

在一个单体应用中，各个组件是在同一进程中运行的，他们之间通过方法调用或函数调用进行通信的。将单体应用变成微服务最大的问题在于对通信模式的改变。仅仅将内存中的方法调用转换为RPC调用这样天真的做法，会导致微服务之间产生繁琐的通信，使得系统表现变糟。取而代之的是，需要用更粗粒度的协议来替代细粒度的服务间通信。

### 脚注
<span id="fn1">1</span>术语“微服务”

<span id="fn2">2</span>

<span id="fn3">3</span>

<span id="fn4">4</span>

<span id="fn5">5</span>

<span id="fn6">6</span>

<span id="fn7">7</span>

<span id="fn8">8</span>