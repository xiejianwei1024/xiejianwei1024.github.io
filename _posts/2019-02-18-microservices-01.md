---
layout: post
title: Microservices
---

翻译自Martin Fowler的[microservices](https://www.martinfowler.com/articles/microservices.html), 翻译于2019年2月18日。

### （microservices）新架构术语的定义
“微服务架构”在过去几年中出现，它描述了一种特定方式：`将软件应用程序设计为一组可独立部署的服务`。尽管这种架构风格没有严格的定义，但是有一些共同的特征：组织业务能力、自动化部署、端点智能化，语言和数据的去中心化控制。

“微服务”——软件架构拥挤大街上的又一个新术语。尽管我们倾向于将其一带而过，但是我们发现它描述了一种越来越吸引人的软件系统风格。在过去的几年里我们看到很多项目使用这种风格，并且到目前为止结果都还不错，以致于这已经变成了我们同事在构建企业级应用时默认使用的架构风格。然而，遗憾的是，并没有太多信息来概括什么是微服务风格以及如何实现它。

简而言之，微服务架构风格[[1]](#fn1)是一种将单个应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，服务间的通信采用轻量级机制(通常是HTTP资源API)。这些服务围绕业务功能构建，并可通过全自动部署机制独立部署。这些服务是没有中央化管理的，它们可以用不同的编程语言开发，使用不同的数据存储技术。

与单体风格作对比有助于开始解释微服务风格：单体应用程序被构建为单一单元。企业应用程序通常由三部分组成：客户端用户接口（由用户机器上浏览器中运行的HTML页面和javascript组成），数据库（由插入到通用关系型数据库管理系统的许多表组成），服务端应用程序。服务器端应用程序将处理 HTTP 请求、执行域逻辑、从数据库检索和更新数据，并选择和填充要发送到浏览器的 HTML 视图。服务端应用程序是一个单一的逻辑可执行单体[[2]](#fn2)。对系统的任何更改都涉及构建和部署服务器端应用程序的新版本。

这样的单体服务器是构建这样的系统最自然的方式。处理请求的所有逻辑都运行在单个进程中，允许使用语言的基本特性将应用程序划分为类、函数和命名空间。您认真地在开发人员的笔记本上运行和测试应用程序，并使用部署管道确保那些变更被完全地测试部署到生产环境中。该单体的水平扩展可以通过在负载均衡器后面运行多个实例来实现。

单体应用程序可以是成功的，但人们日益对他们感到挫败，尤其是随着更多的应用程序被部署在云上。变更周期被捆绑在一起 —— 即使只变更应用程序的一部分，也需要重新构建并部署整个单体。长此以往，通常将很难保持一个良好的模块架构，很难只在需要变更的模块内进行变更。程序扩展要求进行整个应用程序的扩展，而不是对需要的部分应用程序扩展，这会需要更多的资源。

![microservices](https://raw.githubusercontent.com/xiejianwei1024/markdownphotos/master/microservices/sketch.png)
图1：单体和微服务

这些不满导致了微服务架构风格的诞生：以构建一组小型服务的方式来构建应用程序。除了服务是可独立部署和可伸缩的这一事实之外，每个服务还提供了一个严格的模块边界，甚至允许用不同的编程语言编写不同的服务。这些服务也能被不同的团队管理。

我们并不认为微服务风格是新颖的或创新的，其本质至少可以追溯到Unix的设计哲学。但是我们认为，考虑微服务架构的人还不够多，并且如果对其加以使用，许多软件的开发工作能变得更好。

### 微服务架构的特征（九个）
我们无法给出微服务架构风格的一个正式定义，但我们可以尝试去描述我们看到的符合该架构的一些共性。下面所描述的所有这些共性，并不是所有的微服务架构都完全具备，但是我们确实期望大多数微服务架构都具备这些共性中的大多数特性。尽管本文（我们两位）作者已经是这个相当松散的社区的活跃成员，我们的本意还是试图描述我们在工作中和在我们所了解的一些团队，在他们的工作中的所见所闻。特别指出，我们不会制定大家需要遵循的微服务的定义。

#### 1.组件和服务
自从我们涉足软件行业以来，就一直希望通过将组件组装在一起来构建系统，就像我们看到的现实世界中事物的构建方式一样。在过去几十年中，我们已经看到，在公共软件库方面已经取得了相当大的进展，这些软件库是大多数编程语言平台的组成部分。

当谈到组件时，就会碰到一个有关定义的难题，即什么是组件？我们的定义是：<span style="bold">组件</span>是一个可以独立更换和升级的软件单元。

微服务架构也会使用软件库，但其将自身软件进行组件化的主要方法是将软件分解为诸多服务。我们将<span style="bold">软件库(libraries)</span>定义为这样的组件，即它能被链接到一段程序，且能通过内存中的函数来进行调用。然而，服务(services)是进程外的组件，它们通过诸如web service请求或rpc（远程过程调用）这样的机制来进行通信（这不同于许多面向对象的程序中的service object概念[[3]](#fn3)）。

使用服务（而不是以软件库）的方式来实现组件化的一个主要原因是，服务可被独立部署。如果有一个应用程序[[4]](#fn4)）是由在单一进程里的多个软件库所组成的，任何一个组件的的更改都导致必须重新部署整个应用程序。但如果应用程序分解成多个服务，那么单个服务的变更只需要重新部署该服务即可。当然这也不是绝对的，一些服务接口的修改会导致多个服务之间的协同修改。但是一个良好的微服务架构的目的，是通过内聚的服务边界和服务协议方面的演进机制，来将这样的修改变得最小化。

使用服务作为组件的另一个结果是获得更加显示的组件接口。大多数编程语言并没有一个良好的机制来定义显式的[发布接口](https://www.martinfowler.com/bliki/PublishedInterface.html)。通常情况下，这样的接口仅仅是文档声明和团队纪律，来避免客户端破坏组件的封装，从而导致组件间出现过度紧密的耦合。服务通过显示的远程调用机制可以很容易的避免这种情况发生。

如此使用服务，也会有不足之处。比起进程内调用，远程调用更加昂贵。所以远程调用API接口必须是粗粒度的，而这往往更加难以使用。如果需要修改组件间的职责分配，那么当跨越进程边界时，这种组件行为的改动会更加难以实现。

近似地，我们可以把一个个服务映射为一个个运行时的进程，但这仅仅是一个近似。一个服务可能由多进程组成，这些进程总是被一起开发和部署，比如只被这个服务使用的应用进程和数据库。

#### 2.围绕业务功能组织团队
当在寻求将一个大型应用系统分解成几部分时，公司管理层往往会聚焦在技术层面上，这就意味着要组建用户界面团队、服务器端团队和数据库团队。当团队沿着这些技术线分开后，即使要实现软件中一个简单的变更，也会发生跨团队的项目时延和预算审批。在这种情况下，聪明的团队会进行局部优化，“两害相权取其轻”，来直接把代码逻辑塞到他们能访问到的任意应用系统中。换句话说，这种情况会导致代码逻辑散布在系统各处。这就是康威定律[[5]](#fn5)的鲜活实例。

`任何设计（广义上的）系统的组织，都会产生这样一个设计，即该设计的结构与该组织的沟通结构相一致。——梅尔文•康威（Melvyn Conway）, 1967年`

![microservices](https://raw.githubusercontent.com/xiejianwei1024/markdownphotos/master/microservices/conways-law.png)
图2：康威定律在起作用

微服务使用不同的方法来分解系统，即根据业务功能（business capability）来将系统分解为若干服务。这些服务针对该业务领域提供多层次、广泛的软件实现，包括用户界面、持久性存储以及任何对外的协作性操作。因此，团队是跨职能的，它拥有软件开发所需的全方位的技能：用户体验、数据库和项目管理。

![microservices](https://raw.githubusercontent.com/xiejianwei1024/markdownphotos/master/microservices/PreferFunctionalStaffOrganization.png)
图3：被团队边界所强化的服务边界

------------------
侧边栏：微服务有多大？
尽管“微服务”已经成为这种架构风格的一个流行名称，但是这个名字确实会不幸地引发大家对服务规模的关注，并且产生有关什么是“微”的争论。在我们与微服务从业人员的对话中，我们看到了各种规模的服务。据报道，最大的披萨店遵循了亚马逊的“两个披萨团队”(即整个团队可以吃两个披萨)的理念，即最多只能容纳12个人。在较小的规模上，我们已经看到了由6个人组成的团队支持6个服务。

这引出了一个问题，即“每12人做一个服务”和“每人做一个服务”这样有关服务规模的差距，是否已经大到不能将两者都纳入微服务之下？此时，我们认为最好还是把它们归为一类，但是随着探索的深入，我们将来极有可能会改变主意。

------------------

以上述方式来组织团队的公司是[www.comparethemarket.com](http://www.comparethemarket.com)。跨职能团队负责构建和运维每个产品，而每个产品被拆分为多个独立的服务，彼此通过一个消息总线来通信。

大型单体应用程序也可以围绕业务功能进行模块化，尽管这种情况并不常见。当然，我们会敦促构建单体应用程序的大型团队按照业务线来将自己分解为若干小团队。我们在这里看到的主要问题是，它们往往是一个团队包含了太多的业务功能。如果这个“单体”跨越了许多模块的边界，那么这个团队的每一个成员都难以记住所有模块的业务功能。此外，我们看到这些模块的边界需要大量的团队纪律来强制维持。而实现组件化的服务所必要的更加显式的边界，能更加容易地保持团队边界的清晰性。

#### 3.“做产品”而不是“做项目”
我们所看到的大多数应用程序的开发工作都使用这样一种项目模型：目标是交付某一块软件，之后就认为完工了。一旦完工后，软件就被移交给维护团队，接着那个构建该软件的项目团队就会被解散。

微服务的支持者们倾向于避免上述模型，而宁愿采纳“一个团队在一个产品的整个生命周期中都应该保持对其拥有”的理念。通常认为这一点源自于亚马逊的“谁构建，谁运行”的理念，即一个开发团队对一个在生产环境下的软件负全责。这使得开发人员每天都会关注他们的软件在生产环境下是如何运行的，并且增进了他们与客户间的联系，因为他们必须承担一些支持工作。

这样的“产品”理念，是与业务功能联动绑定在一起的。与其将软件视为一组要完成的功能，还不如将其视为一种持续的关系，即软件如何帮助用户持续增强业务功能。

单体应用程序的开发工作也可以遵循上述“产品”理念，但是更小粒度的服务会让服务的开发者和其用户之间的个人关系变得更加容易。

#### 4.“智能端点”与“傻瓜管道”
当在不同的进程之间构建各种通信结构时，我们已经看到许多产品和方法，来强调将大量的智能特性纳入通信机制本身。其中一个典型例子，就是“企业服务总线”(Enterprise Service Bus, ESB)。ESB产品经常包括高度智能的设施，来进行消息的路由、编制(choreography)、转换，并应用业务规则。

------------------
侧边栏：微服务和SOA
当我们谈起微服务时，一个常见的问题就会出现：微服务是否仅仅是十多年前所看到的“面向服务的架构”(Service Oriented Architecture, SOA)？这样问是有道理的，因为微服务风格非常类似于一些支持SOA的人所赞成的观点。然而，问题在于[SOA这个词儿意味着太多不同的东西](https://martinfowler.com/bliki/ServiceOrientedAmbiguity.html)。而且大多数时候，我们所遇到的某些被称作”SOA”的事物，明显不同于本文所描述的风格。这通常由于它们专注于ESB，来集成各个单体应用。

特别地，我们已经看到如此之多的面向服务的拙劣实现——从将系统复杂性隐藏于ESB中的趋势[[6]](#fn6)，到花费数百万进行多年却没有交付任何价值的失败项目，到顽固抑制变化发生的中心化技术治理模型——以至于有时觉得其所造成的种种问题真的不堪回首。

当然，在微服务社区投入使用的许多技术，源自各个开发人员将各种服务集成到各个大型组织的经验。“容错读取”(Tolerant Reader)模式就是这样一个例子。对于Web的广泛使用，使得人们不再使用一些中心化的标准，而使用一些简单的协议。坦率地说，这些中心化的标准，其复杂性已经达到令人吃惊的程度。（任何时候，如果需要一个本体来管理其他各个本体，那么麻烦就大了。）

这种常见的SOA表现，已使得一些微服务的倡导者完全拒绝将自己贴上SOA的标签。尽管其他人会将微服务看作是SOA的一种形式[8]，也许微服务就是以正确的形式来实现面向服务的SOA。不管是哪种情况，SOA意味着如此之多的不同事物，这表明用一个更加干净利落的术语来命名这种架构风格是很有价值的。

------------------

微服务社区主张采用另一种做法：智能端点(smart endpoints)和傻瓜管道(dumb pipes)。使用微服务所构建的各个应用的目标，都是尽可能地实现“高内聚和低耦合”——他们拥有自己的领域逻辑，并且更像是经典Unix的“过滤器”(filter)那样来工作——即接收一个请求，酌情对其应用业务逻辑，并产生一个响应。这些应用通过使用一些简单的REST风格的协议来进行编制，而不去使用诸如下面这些复杂的协议，即”WS-编制”(WS-Choreography)、BPEL或通过位于中心的工具来进行编排(orchestration)。

微服务最常用的两种协议是：带有资源API的HTTP“请求－响应”协议，和轻量级的消息发送协议[[8]](#fn8)。对于前一种协议的最佳表述是：

`成为Web，而不是躲着Web (Be of the web, not behind the web)——Ian Robinson`

这些微服务团队在开发中，使用的是在构建万维网(world wide web)时所使用的原则和协议（并且在很大程度上，这些原则和协议也是在构建Unix系统时所使用的）。那些被使用过的HTTP资源，通常能被开发或运维人员轻易地缓存起来。

最常用的第二种协议，是通过一个轻量级的消息总线来进行消息发送。此时所选择的基础设施通常是“傻瓜”(dumb)型的(仅仅像消息路由器所做的事情那样傻瓜)——像RabbitMQ或ZeroMQ那样的简单实现，即除了提供可靠的异步机制(fabric)以外不做其他任何事情——智能功能存在于那些生产和消费诸多消息的各个端点中，即存在于各个服务中。

在一个单体应用中，各个组件是在同一进程中运行的，他们之间通过方法调用或函数调用进行通信的。将单体应用变成微服务最大的问题在于对通信模式的改变。仅仅将内存中的方法调用转换为RPC调用这样天真的做法，会导致微服务之间产生繁琐的通信，使得系统表现变糟。取而代之的是，需要用更粗粒度的协议来替代细粒度的服务间通信。

#### 5.“去中心化”地治理技术
使用中心化的方式对开发进行治理，其中一个后果，就是趋向于在单一技术平台上制定标准。经验表明，这种做法会带来局限性——不是每一个问题都是钉子，不是每一个方案都是锤子。我们更喜欢根据工作的不同来选用合理的工具。尽管那些单块应用系统能在一定程度上利用不同的编程语言，但是这并不常见。

如果能将单体应用的那些组件拆分成多个服务，那么在构建每个服务时，就可以有选择不同技术栈的机会。要使用Node.js来搞出一个简单的报表页面？尽管去搞。想用C++来做一个特别出彩儿的近乎实时的组件？没有问题。想要换一种不同风格的数据库，来更好地适应一个组件的读取数据的行为？可以重建。

当然，仅仅能做事情，并不意味着这些事情就应该被做——不过用微服务的方法把系统进行拆分后，就拥有了技术选型的机会。

构建微服务的团队也喜欢采用不同的标准方法。与其选用一组写在纸上已经定义好的标准，他们更喜欢编写一些有用的工具，来让其他开发者能够使用，以便解决那些和他们所面临的问题相似的问题。这些工具通常源自他们的微服务实施过程，并且被分享到更大规模的组织中，这种分享有时会使用内部开源的模式来进行。

Netfix公司是遵从上述理念的好例子。将实用且经过实战检验的代码以软件库的方式分享出来，能鼓励其他开发者以相似的方式解决相似的问题，还能在需要的时候选择不同的方案留了一扇门。共享软件库往往集中在解决这样的常见问题，数据存储，进程间通信和我们接下来要讨论的基础设施自动化。

对于微服务社区来说，日常开销管理不是特别的吸引人。并不是说社区不重视服务契约。恰恰相反，它们在社区里出现得更多。这正说明社区正在寻找对其进行管理的各种方法。像[“容错读取”](https://www.martinfowler.com/bliki/TolerantReader.html)和[“消费者驱动的契约”](Consumer-Driven Contracts, http://martinfowler.com/articles/consumerDrivenContracts.html)这样的模式，经常被运用到微服务中。这些都有助于服务契约独立发展。执行消费者驱动的契约作为软件构建的一部分，可以增强开发团队的信心；并且对于服务是否正常的运行，可以提供快速的反馈。
实际上，我们了解到一个澳洲的团队就是使用消费者驱动的契约来驱动构建多个新的服务。他们使用简单的工具，针对每一个服务定义契约。甚至在新服务的代码编写前，已经成为自动化构建的一部分了。然后，服务只构建到满足契约的程度--当构建新软件的时候，避免 'YAGNI'[9](#fn9)困境的一种优雅方式。这些技术和工具围绕着契约成长，通过减少服务间的耦合，从而抑制了中心化契约管理的需求。

------------------
侧边栏：多种编程语言，多种选择可能
作为一个平台，JVM的发展仅仅是将编程语言混合到一个通用平台的最新例子。近十年以来，在平台外层实现更高层次的编程语言，来利用更高层次的抽象，已经成为一个普遍做法。同样，在平台底层以更低层次的编程语言编写性能敏感的代码也很普遍。然而，许多单块系统并不需要这种级别的性能优化，另外DSL和更高层次的抽象也不常用（这令我们感到失望）。相反，许多单块应用通常就使用单一编程语言，并且有对所使用的技术数量进行限制的趋势[10](#fn10)。

------------------

或许去中心化地治理技术的极盛时期，就是亚马逊的“谁构建，谁运行”的风气开始普及的时候。各个团队负责其所构建的软件的所有方面的工作，其中包括7 x 24地对软件进行运维。将运维这一级别的职责下放到团队这种做法，目前绝对不是主流。但是我们确实看到越来越多的公司，将运维的职责交给各个开发团队。Netflix就是已经形成这种风气的另一个组织[11](#fn11)。避免每天凌晨3点被枕边的寻呼机叫醒，无疑是在程序员编写代码时令其专注质量的强大动力。而这些想法，与那些传统的中心化技术治理的模式具有天壤之别。

#### 6.“去中心化”地数据管理
去中心化地管理数据，其表现形式多种多样。在最抽象的层次上，它意味着世界的概念模型在系统之间是不同的。当在一个大型的企业中进行系统集成时，这是一个常见的问题。比如对于“客户”这个概念，从销售人员的视角看，就与从支持人员的视角看有所不同。从销售人员的视角所看到的一些被称之为“客户”的事物，或许在支持人员的视角中根本找不到。而那些在两个视角中都能看到的事物，或许各自具有不同的属性。更糟糕的是，那些在两个视角中具有相同属性的事物，或许在语义上有微妙的不同。

------------------
侧边栏：“实战检验”的标准与“强制执行”的标准
微服务团队倾向于避开企业架构组制定的那种严格的强制标准，而乐于使用甚至宣传使用开放标准(如HTTP、ATOM和其他微格式)，这有点两面性。
关键的区别在于标准是如何制定和执行的。IETF等组织管理的标准只有在更广泛的环境中有几个实时实现时才会成为标准，而这些实现通常来自成功的开源项目。
这些标准与企业世界中的许多标准截然不同，企业世界中的许多标准通常是由近期几乎没有编程经验或过度受供应商影响的团队开发的。

------------------

这个问题在应用程序之间很常见，但也可能发生在应用程序中，特别是当应用程序被划分为单独的组件时。思考这类问题的一个有用的方法，就是使用领域驱动设计（Domain-Driven Design, DDD）中的[“限界上下文”]（Bounded Context，http://martinfowler.com/bliki/BoundedContext.html）的概念。DDD将一个复杂的领域划分为多个限界上下文，并且将其相互之间的关系用图画出来。这个划分过程对于单体应用和微服务架构都是有用的，而且就像前面有关“业务功能”一节中所讨论的那样，在服务和上下文边界之间存在着一种自然的关系，能有助于澄清和强化这种划分。

如同在概念模型上进行去中心化的决策一样，微服务也在数据存储上进行去中心化的决策。尽管各个单块应用更愿意在逻辑上各自使用一个单独的数据库来持久化数据，但是各家企业往往喜欢一系列单块应用共用一个单独的数据库——许多这样的决策是被供应商的各种版权商业模式所驱动出来的。微服务更喜欢让每一个服务来管理其自有数据库。其实现可以采用相同数据库技术的不同数据库实例，也可以采用完全不同的数据库系统。这种方法被称作[“多语种持久化”](Polyglot Persistence, http://martinfowler.com/bliki/PolyglotPersistence.html)。在一个单块系统中也能使用多语种持久化，但是看起来这种方法在微服务中出现得更加频繁。

![microservices](https://raw.githubusercontent.com/xiejianwei1024/markdownphotos/master/microservices/decentralised-data.png)

在各个微服务之间将数据的职责进行“去中心化”的管理，会影响软件更新的管理。处理软件更新的常用方法，是当更新多个资源的时候，使用事务来保证一致性。这种方法经常在单块系统中被采用。

像这样地使用事务，有助于保持数据一致性。但是在时域上会引发明显的耦合，这样当在多个服务之间处理事务时会出现一致性问题。分布式事务实现起来难度之大是臭名远扬的。为此，微服务架构更强调在各个服务之间进行[“无事务”的协调](http://www.enterpriseintegrationpatterns.com/ramblings/18_starbucks.html)。这源自微服务社区明确地认识到下述两点，即数据一致性可能只要求数据在最终达到一致，并且一致性问题能够通过补偿操作来进行处理。

选择以这种方式管理不一致性对于许多开发团队来说是一个新的挑战，但是它经常与业务实践相匹配。通常情况下，为了快速响应需求，商家们都会处理一定程度上的数据“非一致性”，来通过做某种反向过程进行错误处理。只要在一致性更强的情况下，修复错误的成本小于损失业务的成本，那么这种权衡是值得的。

#### 7.“基础设施”自动化
在过去的几年里，基础设施自动化技术已经发生了巨大的变化——特别是云计算和AWS的发展降低了构建、部署和操作微服务的操作复杂性。许多使用微服务构建的产品和系统，正在被这样的团队所构建，即他们都具备极其丰富的[“持续交付”](http://martinfowler.com/bliki/ContinuousDelivery.html)和其前身[“持续集成”](http://martinfowler.com/articles/continuousIntegration.html)的经验。用这种方法构建软件的各个团队，广泛采用了基础设施的自动化技术。如下图的构建流水线所示：

![microservices](https://raw.githubusercontent.com/xiejianwei1024/markdownphotos/master/microservices/basic-pipeline.png)
图5：基本的构建流水线

因为本文并不是一篇有关持续交付的文章，所以下面仅提请大家注意两个持续交付的关键特点。为了尽可能地获得对正在运行的软件的信心，需要运行大量的<span style="blod">自动化测试</span>。让可工作的软件达到“晋级”(Promotion)状态从而“推上”流水线，就意味着可以在每一个新的环境中，对软件进行<span style="blod">自动化部署</span>。

------------------
侧边栏：让“正确地做事”更容易
那些因实现持续交付和持续集成所增加的自动化工作的副产品，是创建一些对开发和运维人员有用的工具。现在，能完成下述工作的工具已经相当常见了，即创建工件(artefacts)、管理代码库、启动一些简单的服务、或增加标准的监控和日志功能。Web上最好的例子可能是[Netflix提供的一套开源工具集](http://netflix.github.io/)，但也有其他一些好工具，包括我们已经广泛使用的[Dropwizard] (http://dropwizard.codahale.com/)。

------------------

一个单体应用程序将会在这些环境中被构建、测试和推进。事实证明，一旦在下述工作上进行了投入，即针对一个单块系统将其通往生产环境的通道进行自动化，那么部署更多的应用系统似乎就不再可怕。记住，持续交付的目的之一，是让“部署”工作变得“无聊”。所以不管是一个还是三个应用系统，只要部署工作依旧很“无聊”，那么就没什么可担心的了[12](#fn12)。

我们所看到的各个团队在广泛使用基础设施自动化实践的另一个领域，是在生产环境中管理各个微服务。与前面我们对比单块系统和微服务所说的正相反，只要部署工作很无聊，那么在这一点上单块系统和微服务就没什么区别。然而，两者在运维领域的情况却截然不同。

![microservices](https://raw.githubusercontent.com/xiejianwei1024/markdownphotos/master/microservices/micro-deployment.png)
图6：两者的模块部署经常会有差异

#### 8.容错设计
使用各个微服务来替代组件，其结果是各个应用程序需要设计成能够容忍这些服务所出现的故障。如果服务提供方不可用，那么任何对该服务的调用都会出现故障。客户端要尽可能优雅地应对这种情况。和单体应用相比，这是一个缺点，因为引入了额外的复杂性来处理这总情况。为此，各个微服务团队在不断地反思：这些服务故障是如何影响用户体验的。Netflix公司所研发的开源测试工具[Simian Army](https://github.com/Netflix/SimianArmy)，能够诱导服务发生故障，甚至能诱导一个数据中心在工作日发生故障，来测试该应用的弹性和监控能力。

------------------
侧边栏："断路器"与“可随时上线的代码”
[“断路器”(Circuit Breaker)](http://martinfowler.com/bliki/CircuitBreaker.html)一词与其他一些模式一起出现在[《发布！》(Release It!)](http://www.amazon.com/gp/product/B00A32NXZO?ie=UTF8&tag=martinfowlerc-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=B00A32NXZO)一书中，例如隔板(Bulkhead)和超时(Timeout)。当构建彼此通信的应用系统时，将这些模式加以综合运用就变得至关重要。Netflix公司的这篇很精彩的博客[Netflix blog entry](http://techblog.netflix.com/2012/02/fault-tolerance-in-high-volume.html)解释了这些模式是如何应用的。

------------------

这种在生产环境中所进行的自动化测试，能足以让大多数运维组织兴奋得浑身颤栗，就像在一周的长假即将到来前那样。这并不是说单体架构风格不能构建先进的监控系统——只是根据我们的经验，这在单块系统中并不常见罢了。

由于服务在任何时候都可能失败，因此能够快速检测故障并在可能的情况下自动恢复服务非常重要。各个微服务的应用都将大量的精力放到了应用程序的实时监控上，来检查“架构元素指标”（例如数据库每秒收到多少请求）和“业务相关指标”（例如系统每分钟收到多少订单）。当系统某个地方出现问题，语义监控系统能提供一个预警，来触发开发团队进行后续的跟进和调查工作。

这对于一个微服务架构是尤其重要的，因为微服务对于[服务编制(choreography)和事件协作](http://martinfowler.com/eaaDev/EventCollaboration.html)的偏好，会导致“突发行为”。尽管许多权威人士对于偶发事件的价值持积极态度，但事实上，“突发行为”有时是一件坏事。在能够快速发现有坏处的“突发行为”并进行修复的方面，监控是至关重要的。

------------------
侧边栏：“同步调用”有害
一旦在一些服务之间进行多个同步调用，就会遇到宕机的乘法效应。简而言之，这意味着整个系统的宕机时间，是每一个单独模块各自宕机时间的乘积。此时面临着一个选择：是让模块之间的调用异步，还是去管理宕机时间？在英国卫报网站www.guardian.co.uk，他们在新平台上实现了一个简单的规则——每一个用户请求都对应一个同步调用。然而在Netflix公司，他们重新设计的平台API将异步性构建到API的机制(fabric)中。

------------------

单体应用也能构建得像微服务那样来实现透明的监控系统——实际上，它们也应该如此。差别是，绝对需要知道那些运行在不同进程中的服务，在何时断掉了。而如果在同一个进程内使用软件库的话，这种透明的监控系统就用处不大了。


那些微服务团队希望在每一个单独的服务中，都能看到先进的监控和日志记录装置。例如显示“运行/宕机”状态的仪表盘，和各种运维和业务相关的指标。另外我们经常在工作中会碰到这样一些细节，即断路器的状态、当前的吞吐率和延迟，以及其他一些例子。

#### 9.“演进式”设计
那些微服务的从业者们，通常具有演进式设计的背景，而且通常将服务的分解，视作一个额外的工具，来让应用开发人员能够控制应用系统中的变化，而无须减少变化的发生。变化控制并不一定意味着要减少变化——在正确的态度和工具的帮助下，就能在软件中让变化发生得频繁、快速且经过了良好的控制。

每当试图要将软件系统分解为各个组件时，就会面临这样的决策，即如何进行切分——我们决定切分应用系统时应该遵循的原则是什么？一个组件的关键属性，是具有独立更换和升级的特点[13]——这意味着，需要寻找这些点，即想象着能否在其中一个点上重写该组件，而无须影响该组件的其他合作组件。事实上，许多做微服务的团队会更进一步，他们明确地预期许多服务将来会报废，而不是守着这些服务做长期演进。

英国卫报网站是一个好例子。原先该网站是一个以单块系统的方式来设计和构建的应用系统，然而它已经开始向微服务方向进行演进了。原先的单块系统依旧是该网站的核心，但是在添加新特性时他们愿意以构建一些微服务的方式来进行添加，而这些微服务会去调用原先那个单块系统的API。当在开发那些本身就带有临时性特点的新特性时，这种方法就特别方便，例如开发那些报道一个体育赛事的专门页面。当使用一些快速的开发语言时，像这样的网站页面就能被快速地整合起来。而一旦赛事结束，这样页面就可以被删除。在一个金融机构中，我们已经看到了一些相似的做法，即针对一个市场机会，一些新的服务可以被添加进来。然后在几个月甚至几周之后，这些新服务就作废了。


这种强调可更换性的特点，是模块化设计一般性原则的一个特例，通过“变化模式”(pattern of change)[14]来驱动进行模块化的实现。大家都愿意将那些能在同时发生变化的东西，放到同一个模块中。系统中那些很少发生变化的部分，应该被放到不同的服务中，以区别于那些当前正在经历大量变动(churn)的部分。如果发现需要同时反复变更两个服务时，这就是它们两个需要被合并的一个信号。

把一个个组件放入一个个服务中，增大了作出更加精细的软件发布计划的机会。对于一个单块系统，任何变化都需要做一次整个应用系统的全量构建和部署。然而，对于一个个微服务来说，只需要重新部署修改过的那些服务就够了。这能简化并加快发布过程。但缺点是：必须要考虑当一个服务发生变化时，依赖它并对其进行消费的其他服务将无法工作。传统的集成方法是试图使用版本化来解决这个问题。但在微服务世界中，大家更喜欢将[版本化作为最后万不得已的手段](http://martinfowler.com/articles/enterpriseREST.html#versioning)来使用。我们可以通过下述方法来避免许多版本化的工作，即把各个服务设计得尽量能够容错，来应对其所依赖的服务所发生的变化。

#### 未来的方向是“微服务”吗？


### 脚注
<span id="fn1">1</span>术语“微服务”

<span id="fn2">2</span>

<span id="fn3">3</span>

<span id="fn4">4</span>

<span id="fn5">5</span>

<span id="fn6">6</span>

<span id="fn7">7</span>

<span id="fn8">8</span>

<span id="fn9">9</span>

<span id="fn10">10</span>

<span id="fn11">11</span>

<span id="fn12">12</span>