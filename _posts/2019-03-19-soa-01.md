---
layout: post
title: Service-oriented architecture
---

翻译自维基百科的[Service-oriented_architecture](https://en.wikipedia.org/wiki/Service-oriented_architecture), 翻译于2019年3月19日。

Service-oriented architecture（SOA）是一种软件设计风格，在这种设计风格下，通过应用程序组件的形式向其他的组件提供服务，提供服务的方式是基于网络的一种通信协议。SOA的基本原则是独立于厂商、产品、技术。服务是一种离散的功能单元，可以远程访问，可以独立的进行操作和更新，比如说在线获取一张信用卡的账单。

根据SOA许多定义之一，服务有4个属性：
1．从逻辑上来说，服务表示一个业务活动，并且是具有特定的结果。
2．服务是自我包含的。（可以自己提供服务）
3．对于消费者来说，服务是一个黑盒。（消费者不需要关系服务里面是什么）
4．服务还可能包含其他的底层服务。

服务最初叫Service-Based Architecture，在1998年的时候，一个团队开发集成功能管理服务，业务进程类型服务，基于工作单元，使用CORBA进行进程间的通信。

不同的服务可以联合起来使用，以提供大型的软件应用功能，SOA与模块化编程共享一个原则。SOA集成分布式的，独立维护和独立部署的软件组件。SOA通过技术和标准，使基于网络的组件间的通信和协作成为可能，尤其是基于IP网络。

#### 概览
在SOA中，服务使用协议来描述如何使用元数据传递和解析消息。元数据描述了，服务的功能特性和服务的质量特性。面向服务的体系结构旨在允许用户将大块功能组合起来，形成纯粹由现有服务构建的应用程序，并以特定的方式组合它们。服务向请求者提供一个简单的接口，该接口抽象出底层复杂性，以黑盒的形式。此外，用户还可以访问这些独立的服务，而不需要知道它们的内部实现。

#### 定义的概念
相关的面向服务术语促进了服务之间的松散耦合。SOA将功能分离为不同的单元(或服务)，开发人员可以通过网络访问这些单元或服务，以便允许用户在应用程序的生产中组合和重用它们。这些服务及其对应的使用者通过以定义良好的共享格式传递数据，或通过协调两个或多个服务之间的活动来彼此通信。

面向服务的体系结构在2009年10月发布了一个宣言。这就产生了六个核心价值观，具体如下:
1.业务价值比技术策略更重要。
2.战略目标比具体项目的利益更重要。
3.内在的互操作性比定制集成更重要。
4.共享服务比特定用途的实现更重要。
5.灵活性比优化更重要。
6.进化的细化比追求最初的完美更重要。

SOA可以被看作是一个统一体的一部分，这个统一体的范围从较老的分布式计算概念和模块化编程到SOA，再到当前mashup、SaaS和云计算的实践(有些人将其视为SOA的后代)。

#### 原则
目前还没有与面向服务的体系结构的确切组成相关的行业标准，尽管许多行业来源已经发布了自己的原则。其中一些包括以下内容:
标准化的服务合同<br/>
服务遵循标准通信协议，由给定服务集中的一个或多个服务描述文档共同定义。<br/>
服务引用自治(松耦合的一个方面)<br/>
服务之间的关系被最小化到它们只知道存在的程度。<br/>
服务位置透明性(松耦合的一个方面)<br/>
服务可以从网络中它所在的任何位置调用，无论它在哪里。<br/>
服务寿命<br/>
服务的设计应该是长期的。在可能的情况下，如果服务不需要新特性，就应该避免强制消费者进行更改，如果您今天调用服务，那么明天就应该能够调用相同的服务。<br/>
忽视服务<br/>
服务充当黑盒，即它们的内部逻辑对消费者隐藏。<br/>
服务的自主权<br/>
服务是独立的，并且从设计时和运行时的角度控制它们封装的功能。<br/>
服务无状态<br/>
服务是无状态的，即要么返回请求的值，要么提供异常，从而最小化资源的使用。<br/>
服务粒度<br/>
确保服务具有足够大小和范围的原则。服务提供给用户的功能必须是相关的。<br/>
服务标准化<br/>
服务被分解或合并(规范化)以最小化冗余。在某些情况下，可能不需要这样做，这些情况下需要性能优化、访问和聚合。<br/>
服务的可组合性<br/>
服务可用于组合其他服务。<br/>
服务发现<br/>
服务由交流元数据补充，通过这些元数据可以有效地发现和解释服务。<br/>
服务的可重用性<br/>
逻辑被划分为各种服务，以促进代码的重用。<br/>
服务封装<br/>
许多最初没有在SOA下计划的服务可能被封装或成为SOA的一部分。<br/>

#### 模式
每个SOA构建块都可以扮演以下三个角色之一:<br/>
服务提供者<br/>
它创建一个web服务并将其信息提供给服务注册中心。每个提供者都在争论如何公开和为什么公开哪个服务，哪个更重要:安全性还是简单可用性，提供服务的价格等等。提供者还必须决定服务应该为给定的代理服务列出什么类别，以及使用该服务需要什么样的贸易伙伴协议。<br/>

服务代理、服务注册中心或服务存储库<br/>
它的主要功能是使任何潜在的请求者都可以获得关于web服务的信息。实现代理的人决定代理的范围。公共代理在任何地方都是可用的，但是私有代理只对有限数量的公众可用。UDDI是提供Web服务发现的早期尝试，不再受到积极支持。<br/>

服务请求者/消费者<br/>
它使用各种find操作在代理注册中心中定位条目，然后绑定到服务提供者，以便调用其中一个web服务。无论服务使用者需要哪个服务，他们都必须将其带入代理，将其与相应的服务绑定，然后使用它。如果服务提供多个服务，则可以访问多个服务。<br/>

服务消费者-提供者关系由标准化服务契约控制，该契约包含业务部分、功能部分和技术部分。<br/>

服务组合模式有两种广泛的高级体系结构样式:编排和编制。不绑定到特定体系结构风格的低层企业集成模式在SOA设计中仍然是相关的和合格的。<br/>

#### 实现方法
面向服务的体系结构可以用web服务实现。这样做是为了使功能构建块可以通过独立于平台和编程语言的标准Internet协议访问。这些服务可以表示新的应用程序，也可以只是现有遗留系统的包装器，以使它们支持网络。

实现者通常使用web服务标准构建SOA。SOAP就是一个例子，在W3C(World Wide Web Consortium)于2003年推荐了1.2版之后，它获得了广泛的行业接受。这些标准(也称为web服务规范)还提供了更好的互操作性，并提供了对专有供应商软件的一些保护。但是，也可以使用任何其他基于服务的技术(如Jini、CORBA或REST)来实现SOA。

架构可以独立于特定的技术运行，因此可以使用广泛的技术来实现，包括:
基于WSDL和SOAP的Web服务<br/>
消息传递，例如ActiveMQ、JMS、RabbitMQ<br/>
RESTful HTTP，使用具象状态传输(Representational state transfer, REST)构成自己的基于约束的体系结构风格<br/>
OPC-UA<br/>
WCF(微软的Web服务实现，构成WCF的一部分)<br/>
Apache Thrift<br/>
SORCER<br/>

实现可以使用这些协议中的一个或多个，例如，可以使用文件系统机制在符合SOA概念的流程之间按照定义的接口规范通信数据。关键是具有定义接口的独立服务，可以调用这些接口以标准方式执行其任务，而不需要服务预先了解调用应用程序，也不需要应用程序知道或需要知道服务实际如何执行其任务。SOA支持通过组合松散耦合和互操作的服务来构建应用程序的开发。

这些服务基于独立于底层平台和编程语言的正式定义(或契约，例如WSDL)进行互操作。接口定义隐藏了特定于语言的服务的实现。因此，基于SOA的系统可以独立于开发技术和平台(如Java、. net等)运行。例如，在.net平台上运行的c#编写的服务和在Java EE平台上运行的Java编写的服务都可以由一个公共复合应用程序(或客户机)使用。运行在任何平台上的应用程序也可以将运行在另一个平台上的服务作为web服务使用，从而促进重用。托管环境还可以包装COBOL遗留系统，并将它们表示为软件服务。

高级编程语言(如BPEL和ws - cdl等规范和ws - coordination扩展的服务理念通过提供一个方法定义和支持细粒度的服务编排成更粗粒度业务服务,架构师可以反过来融入工作流和业务流程中实现复合应用程序或门户网站。

面向服务的建模是一个SOA框架，它标识了指导SOA实践者概念化、分析、设计和架构其面向服务资产的各种规程。面向服务的建模框架(Service-oriented modeling framework, SOMF)提供了一种建模语言和一个工作结构或“map”，该工作结构或“map”描述了有助于成功的面向服务建模方法的各种组件。它说明了标识服务开发计划的“要做什么”方面的主要元素。该模型使实践者能够制定项目计划并识别面向服务的活动的里程碑。SOMF还提供了一个通用的建模符号来处理业务和IT组织之间的对齐。
