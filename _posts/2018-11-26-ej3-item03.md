---
layout: post
title: 条款3：优先选择依赖注入而非硬编码资源
---
&emsp;&emsp;使用私有构造函数或枚举类型强制singleton属性。单例是一个只实例化一次的类。单例通常表示无状态对象，如函数(Item 24)或本质上惟一的系统组件。**将类设置为单例会使测试它的客户端变得困难**这是因为，除非它实现了一个作为它的类型的接口，否则不可能用mock实现代替singleton。<br/>
&emsp;&emsp;实现单例有两种常见的方法。这两种方法都基于保持构造函数私有和导出公共静态成员来提供对唯一实例的访问。在第一个方法中，成员是一个final的字段：<br/>
```java
// Singleton with public final field 
public class Elvis {
    public static final Elvis INSTANCE = new Elvis();
    private Elvis() { ... }
    public void leaveTheBuilding() { ... }
}
```
&emsp;&emsp;私有构造函数只被调用一次，用于初始化 public static final field Elvis.INSTANCE。缺少公共或受保护的构造函数保证了一个“单精灵”的宇宙：一旦初始化了Elvis类，就会存在一个Elvis实例—不多也不少。客户做的任何事情都不能改变这一点，但有一点需要注意:有特权的客户端可以借助AccessibleObject.setAccessibl方法反射地调用私有构造函数。如果需要抵御这种攻击，请修改构造函数，要求它创建第二个实例时抛出异常。<br/>
&emsp;&emsp;在实现单例的第二种方法中，public成员是一个静态工厂方法:<br/>
```java
// Singleton with static factory
public class Elvis {
    private static final Elvis INSTANCE = new Elvis();
    private Elvis() { ... }
    public static Elvis getInstance() { return INSTANCE; }
    public void leaveTheBuilding() { ... } 
} 
```
&emsp;&emsp;所有调用Elvis.getInstance方法的都返回相同的对象引用，并且不会创建其他的Elvis实例(与前面提到的警告相同)。<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>
&emsp;&emsp;<br/>

英文生词：

enforce /ɪn'fɔrs/ 
vt. 实施，执行；强迫，强制

intrinsically /ɪn'trɪnsɪkəlɪ/ 
adv. 本质地；内在地；固有地

substitute /'sʌbstɪtjuːt/
n. 代用品；代替者
vi. 替代
vt. 代替

sole /səʊl/ 
adj. 唯一的；单独的；仅有的

lack of
没有，缺乏；不足，不够

caveat/'kævɪæt; 'keɪ-/ 
n. 警告；

privileged /'prɪvəlɪdʒd/ 
adj. 享有特权的；有特别恩典的